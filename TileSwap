class Game_Map
  #Overrides and replaces Hime's perform_load_new_map_data
  def perform_load_new_map_data
    @need_refresh_tiles = false
    for z in 0...3
      @updated_tiles.clear!
      tiles = $game_system.has_swap_tiles?(@map_id, z) ? $game_system.swapped_tiles[map_id][z] : nil
      regions = $game_system.has_swap_region?(@map_id, z) ? $game_system.swapped_region_tiles[map_id][z] : nil
      masks = $game_system.has_swap_mask?(@map_id, z) ? $game_system.swapped_mask_tiles[map_id][z] : nil
      position_tiles = $game_system.has_swap_pos?(@map_id, z) ? $game_system.swapped_pos_tiles[map_id][z] : nil
      next unless tiles or masks or regions or position_tiles
      for y in 0...height
        positions = position_tiles.nil? ? nil : position_tiles[y]
        for x in 0...width
                    new_tile = nil
          if positions
            new_tile = positions[x]
          end
          if new_tile.nil? and masks
            priority = nil
            masks.each {|mask, tid|
              if (priority.nil? or mask.priority > priority) and mask[x,y]
                new_tile = tid
                priority = mask.priority
              end
            }
          end
          if new_tile.nil? and regions
            new_tile = regions[tile_id(x, y, 3) >> 8] # region_id(x,y) - but without the extra valid?(x,y) overhead
          end
          old_tid = tile_id(x, y, z)
          # Stores the index of each original tile, assuming it is in the
          # auto-tile range.
          index = (tile_id(x, y, z) - 2048) % 48 if old_tid >= 2048
          if new_tile.nil? and tiles
            old_tid = old_tid - index if old_tid >= 2048
            new_tile = tiles[old_tid]
          end
          next if new_tile.nil?
          old_tid = tile_id(x, y, z)
          old_tid = old_tid - index if old_tid >= 2048
          next if new_tile == old_tid # quicker than the autotile recalibration overhead for a single tile
          # Copies the index value from the old tile to the new tile assuming
          # both are in the autotile range and are swapping by 
          # tiles and ONLY by tiles.
          if tiles and !position_tiles and !masks and !regions and old_tid >= 2048 and new_tile >= 2048
            @map.data[x, y, z] = new_tile + index
          else
            @map.data[x, y, z] = new_tile
          end
          @updated_tiles[x, y] = true
        end
      end
      @updated_tiles.grow
      # KilloZapit's auto-tile generation code is only run if we are not 
      # swapping by tiles and ONLY by tiles.
      if tiles and !position_tiles and !masks and !regions 
      else
      #-----------------------------------------------------------------------------
      # The following was originally based on auto-tile generation code by KilloZapit
      #-----------------------------------------------------------------------------
       @updated_tiles.each { |x, y, valid_left, valid_top, valid_right, valid_bottom|
        autotile = (tile_id(x, y, z) - 2048) / 48
        next if autotile < 0
        index = 0
        if autotile == 5 or autotile == 7 or autotile == 9 or autotile == 11 or autotile == 13 or autotile == 15
          # waterfall
          index |= 1 if valid_left && autotile_edge(autotile, x - 1, y, z)
          index |= 2 if valid_right && autotile_edge(autotile, x + 1, y, z)
        elsif autotile >= 48 and autotile <= 79 or autotile >= 88 and autotile <= 95 or autotile >= 104 and autotile <= 111 or autotile >= 120 and autotile <= 127
          # wall
          index |= 1 if valid_left && autotile_wall_edge(autotile, x - 1, y, z)
          index |= 2 if valid_top && autotile_edge(autotile, x, y - 1, z)
          index |= 4 if valid_right && autotile_wall_edge(autotile, x + 1, y, z)
          index |= 8 if valid_bottom && autotile_edge(autotile, x, y + 1, z)
        else
          # normal
          edge = 0
          edge |= 1 if valid_left && autotile_edge(autotile, x - 1, y, z)
          edge |= 2 if valid_top && autotile_edge(autotile, x, y - 1, z)
          edge |= 4 if valid_right && autotile_edge(autotile, x + 1, y, z)
          edge |= 8 if valid_bottom && autotile_edge(autotile, x, y + 1, z)
          if edge == 0 # -
            index |= 1 if valid_top && valid_left && autotile_edge(autotile, x - 1, y - 1, z)
            index |= 2 if valid_top && valid_right && autotile_edge(autotile, x + 1, y - 1, z)
            index |= 4 if valid_bottom && valid_right && autotile_edge(autotile, x + 1, y + 1, z)
            index |= 8 if valid_bottom && valid_left && autotile_edge(autotile, x - 1, y + 1, z)
          elsif edge == 1 # l
            index |= 1 if valid_top && valid_right && autotile_edge(autotile, x + 1, y - 1, z)
            index |= 2 if valid_bottom && valid_right && autotile_edge(autotile, x + 1, y + 1, z)
            index |= 16
          elsif edge == 2 # u
            index |= 1 if valid_bottom && valid_right && autotile_edge(autotile, x + 1, y + 1, z)
            index |= 2 if valid_bottom && valid_left && autotile_edge(autotile, x - 1, y + 1, z)
            index |= 20
          elsif edge == 3 # lu
            index = valid_bottom && valid_right && autotile_edge(autotile, x + 1, y + 1, z) ? 35 : 34
          elsif edge == 4 # r
            index |= 1 if valid_bottom && valid_left && autotile_edge(autotile, x - 1, y + 1, z)
            index |= 2 if valid_top && valid_left && autotile_edge(autotile, x - 1, y - 1, z)
            index |= 24
          elsif edge == 5 # lr
            index = 32
          elsif edge == 6 # ur
            index = valid_bottom && valid_left && autotile_edge(autotile, x - 1, y + 1, z) ? 37 : 36
          elsif edge == 7 # lur
            index = 42
          elsif edge == 8 # d
            index |= 1 if valid_top && valid_left && autotile_edge(autotile, x - 1, y - 1, z)
            index |= 2 if valid_top && valid_right && autotile_edge(autotile, x + 1, y - 1, z)
            index |= 28
          elsif edge == 9 # ld
            index = valid_top && valid_right && autotile_edge(autotile, x + 1, y - 1, z) ? 41 : 40
          elsif edge == 10 # ud
            index = 33
          elsif edge == 11 # lud
            index = 43
          elsif edge == 12 # rd
            index = valid_top && valid_left && autotile_edge(autotile, x - 1, y - 1, z) ? 39 : 38
          elsif edge == 13 # lrd
            index = 44
          elsif edge == 14 # urd
            index = 45
          elsif edge == 15 # lurd
            index = 46
          else # wtf
            index = 47
          end
        end
        @map.data[x, y, z]= 2048 + (48 * autotile) + index
      }
      end
    end
  end
end
